% % Apunte de modulos basicos
%
\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}


\hypersetup{%
 % Para que el PDF se abra a página completa.
 pdfstartview= {FitH \hypercalcbp{\paperheight-\topmargin-1in-\headheight}},
 pdfauthor={Cátedra de Algoritmos y Estructuras de Datos II - DC - UBA},
 pdfkeywords={Módulos básicos},
 pdftitle={Módulos básicos de diseño},
 pdfsubject={Módulos básicos de diseño}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PARAMETROS A SER MODIFICADOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%cuatrimestre de acuerdo a la opcion
\newcommand{\Cuatrimestre}{$2^\mathrm{do}$ cuatrimestre de 2021}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OTRAS OPCIONES QUE NO HAY QUE MODIFICAR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%opening
\title{Resumen SQL}
\author{Programacion Frontend}
\date{Julio 2023}

% Acomodo fancyhdr.
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Resumen SQL}
\rhead{Julio 2023}
\cfoot{\thepage /\pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}
\setlength{\headheight}{13pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMANDOS QUE ALGUN DIA PUEDAN FORMAR UN PAQUETE.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}

%pagina de titulo
\thispagestyle{empty}
\maketitle
\tableofcontents

\newpage

\section{Clausulas}

\subsection{Clausula SELECT}

\TipoVariable{SELECT * FROM users} se utiliza para seleccionar todo desde la tabla \TipoVariable{users}. Ahora, vamos a insertar en la tabla users los campos (columnas) name, surname y age de la siguiente manera:
\newline
\newline
\TipoVariable{INSERT INTO users (name,surname,age)  VALUES ('Ezequiel', 'Rueda Sanchez', '24')}
\newline
\newline
Observamos que al ejecutar esta instrucción obtenemos:
\newline
\newline
\TipoVariable{'Result: query executed successfully. Took 5ms'}.
\newline
\newline
Esto es así porque cualquier operación (en este caso \TipoVariable{INSERT}) que realicemos con SQL la toma como una consulta.
\newline
\newline
Ahora si ejecutamos \TipoVariable{SELECT * FROM users} nos devuelve la siguiente tabla:
\newline
\newline
\begin{tabular}{|c|c|c|}
	\hline
	Name     &  Surname         &   Age     \\ \hline
	Ezequiel &  Rueda Sanchez   &   24      \\ \hline
\end{tabular}
\newline
\newline
\newline
También puedo agregar varios usuarios al mismo tiempo de la siguiente manera:
\newline
\newline
\TipoVariable{INSERT into users (name, surname,  age) VALUES ('Pedro', 'Rodriguez', 26), ('Carlos', 'Sanchez', 18), ('Francisco', 'Alvarez', 52)}
\newline
\newline
Ahora, ejecuto \TipoVariable{SELECT * FROM users} para ver el nuevo estado de la tabla.
\newline
\newline
Al ejecutar \TipoVariable{SELECT age FROM users}, filtramos la tabla para que solo nos devuelva el campo \TipoVariable{age} con sus respectivos registros.
\newline
\newline
Ahora insertamos el registro \TipoVariable{('Francisco', 'Alvarez', 52)} y tenemos dos registros iguales. 
\newline
\newline
¿Como los podemos diferenciar?
\newline
\newline
No hay manera de diferenciarlos. Para eso, utilizamos los \textbf{identificadores}. Tenemos los $primary$ $keys$ y los $foreign$ $keys$.
\newline
\newline
Para ello, vamos a modificar la tabla colocando un nuevo campo llamado \TipoVariable{id\_user} de tipo integer. 
\newline
\newline
Ahora, al mostrar la tabla (\TipoVariable{SELECT * FROM users}), observamos que todos los registros tienen el campo \TipoVariable{id\_user} con \TipoVariable{NULL}.
\newline
\newline
Entonces, vamos a borrar todos los registros ejecutando \TipoVariable{DELETE FROM users}.
\newline
\newline
Ahora, vuelvo a modificar la tabla y puedo aplicar la opción \TipoVariable{AI} (Auto Increment) para que cada registro sea unico y automáticamente se me aplica la opción \TipoVariable{PK} (Primary Key) porque nos garantiza una integridad referencial, es decir, podemos hacer referencias a registros sin tener valores duplicados.
\newline
\newline
Por lo tanto, ahora a medida que vayamos insertando registros el id se va a auto incrementar en uno para que no haya ninguna posibilidad de que dos registros sean exactamente iguales. Luego, armamos una tabla nueva que llamamos \TipoVariable{turnos\_medicos} donde insertamos los campos \TipoVariable{id\_turno}, \TipoVariable{profesional}, \TipoVariable{id\_user} (F(oreign) K(ey) o clave foranea), \TipoVariable{motivo} y \TipoVariable{horario}.
\newline
\newline
Decimos que una clave es foránea en una tabla cuando hace referencia a una clave primaria (PK) de otra tabla y se le debe colocar el mismo nombre tanto en la tabla como en la tabla donde es PK.
\newline
\newline
De ahora en adelante, vamos a trabajar con la base de datos de \textbf{Northwind}.
\newline
\newline
\newline
Supongamos que queremos cambiar el nombre del campo \TipoVariable{LastName}. No lo puedo hacer desde la tabla pero puedo modificarlo localmente con \TipoVariable{SELECT LastName AS surname FROM Employees}.
\newline
\newline
De ahora en adelante, esta renombrado localmente como \TipoVariable{surname} aunque en la tabla el campo sigue siendo \TipoVariable{LastName}.
\newline
\newline
También podemos renombrarlo varios campos mediante comas. Por ejemplo: 
\newline
\newline
\TipoVariable{SELECT LastName AS surname, FirstName AS name  FROM Employees}
\newline
\newline
Por lo tanto, utilizamos la cláusula \TipoVariable{AS} para que una tabla/campo sea mas declarativo o descriptivo.
\newline
\newline
Ahora, volvemos a ver toda la de products ejecutando \TipoVariable{SELECT * FROM Products}.
\newline
\newline
Luego, quiero ordenar la tabla pero según el precio (campo \TipoVariable{PRICE}) de forma creciente. Sabemos que por defecto, los productos están ordenados según el numero de \TipoVariable{ID} porque son autoincrementables. Para ello ejecutamos las siguientes lineas:
\newline
\newline
\TipoVariable{SELECT * FROM Products ORDER BY price}
\newline
\newline
También podríamos ejecutar \TipoVariable{SELECT * FROM Products ORDER BY price ASC}. Y  obtenemos el mismo resultado.
\newline
\newline
Si queremos ordenar los precios de forma decreciente, ejecutamos las siguientes lineas:
\newline
\newline
\TipoVariable{SELECT * FROM Products ORDER BY price DESC}
\newline
\newline
\TipoVariable{ASC} y \TipoVariable{DESC} funcionan tanto para los precios como para el campo text \TipoVariable{ProductName}. En este caso, por defecto o \TipoVariable{ASC} ordena alfabeticamente de menor a mayor (de la A a la Z) y \TipoVariable{DESC} ordena alfabeticamente de mayor a menor (de la Z a la A).
\newline
\newline
Notemos que la tabla ordena de acuerdo a la siguiente jerarquía:
\newline
\newline
\TipoVariable{NULL $>$ NUMEROS $>$ CARACTERES ESPECIALES $>$ CARACTERES COMUNES}
\newline
\newline
Por lo tanto, si agregamos un registro \TipoVariable{NULL} en la tabla de \TipoVariable{Products} y ejecutamos:
\newline
\newline
\TipoVariable{SELECT * FROM Products ORDER BY ProductName ASC}
\newline
\newline
El registro \TipoVariable{NULL} se convierte en el primero de la tabla.
\newline
\newline
Ahora, si quiero colocar todos los registros NULL al final de la tabla ejecuto:
\newline
\newline
\TipoVariable{SELECT * FROM Products ORDER BY ProductName ASC NULLS LAST}
\newline
\newline
\TipoVariable{ASC} esta ordenando de forma creciente, es decir, los \TipoVariable{NULLs} van al principio pero al ejecutar \TipoVariable{NULLs LAST} estoy indicando que los voy a colocar al final de la tabla.
\newline
\newline
Ahora, si quiero colocar todos los registros NULL al principio de la tabla cuando estoy ordenando de forma descendente ejecuto:
\newline
\newline
\TipoVariable{SELECT * FROM Products ORDER BY ProductName DESC NULLS FIRST}
\newline
\newline
\TipoVariable{ASC} esta ordenando de forma creciente, es decir, los \TipoVariable{NULLs} van al principio pero al ejecutar \TipoVariable{NULLs LAST} estoy indicando que los voy a colocar al final de la tabla.
\newline
\newline
Ahora, si queremos ordenar la tabla de una manera \TipoVariable{RANDOM} ejecutamos:
\newline
\newline
\TipoVariable{SELECT * FROM Products ORDER BY RANDOM()}
\newline
\newline
Ahora, si ejecutamos:
\newline
\newline
\TipoVariable{SELECT * FROM Products ORDER BY ProductName, SupplierID DESC}
\newline
\newline
Se ordena primero respecto a \TipoVariable{ProductName} y en caso de que los registros sean iguales, en base a \TipoVariable{SupplierID}. Ahora, si queremos eliminar todos los repetidos por ejemplo de \TipoVariable{ProductName} ejecutamos:
\newline
\newline
\TipoVariable{SELECT DISTINCT ProductName FROM Products}
\newline
\newline
Con esto eliminamos todas las repeticiones de \TipoVariable{NULL} y solo nos quedamos con una (con la primera aparición).
\newline
\newline
Ademas, podemos ordenar los registros del campo ProductName ejecutando lo siguiente:
\newline
\newline
\TipoVariable{SELECT DISTINCT ProductName FROM Products ORDER BY ProductName DESC}
\newline
\newline
Por lo tanto, primero solo se deja la primera aparición de cada producto y luego se ordena los mismos de manera decreciente.
\newpage

\subsection{Clausula WHERE}

Supongamos que queremos ver cual es el nombre asociado al \TipoVariable{productId} numero 14. Entonces, comenzamos ejecutando:
\newline
\newline
\TipoVariable{SELECT ProductName FROM Products} obteniendo el listado de productos.
\newline
\newline
Ahora si queremos ver cual es el nombre asociado al productId numero 14 ejecutamos:
\newline
\newline
\TipoVariable{SELECT ProductName FROM Products WHERE ProductID = 14}
\newline
\newline
Si queremos obtener toda la información del registro con \TipoVariable{ProductID = 14} ejecutamos:
\newline
\newline
\TipoVariable{SELECT * FROM Products WHERE ProductID = 14}
\newline
\newline
Ahora, supongamos que solo tenemos un presupuesto de 40USD y quiero ver que productos puedo comprar. Para ello, ejecuto lo siguiente:
\newline
\newline
\TipoVariable{SELECT * FROM Products WHERE Price $<$ 40}
\newline
\newline
Ahora, supongamos que queremos eliminar el registro \TipoVariable{NULL} con \TipoVariable{ProductID = 80}. Para ello, ejecutamos lo siguiente:
\newline
\newline
\TipoVariable{DELETE FROM Products WHERE ProductID = 80}
\newline
\newline
Observemos que no es necesario escribir \TipoVariable{*} luego del \TipoVariable{DELETE}.

\subsection{Clausula UPDATE}

Supongamos que queremos el precio del producto \TipoVariable{Chais} (\TipoVariable{ProductID = 1}) que es de 18USD por 20USD. Para ello, ejecutamos:
\newline
\newline
\TipoVariable{UPDATE Products SET Price = 20 WHERE ProductId = 1}
\newline
\newline
Luego, ejecutamos \TipoVariable{SELECT * FROM Products} para ver el nuevo estado de la tabla.
\newline
\newline
Ahora, si queremos modificar el valor de mas de un campo nos alcanza con enumerar el campo seguido de una coma (,) y listo.
\newline
\newline
Por ejemplo, \TipoVariable{UPDATE Products SET Price = 20, ProductName = 'Chais modificado' WHERE ProductId = 1}
\newline
\newline
Para modificar el campo \TipoVariable{Price} y \TipoVariable{ProductName}.   
\newpage

\subsection{Clausula AND}

Ahora, vamos a la tabla de clientes (Customers). Entonces, si queremos consultar por aquellos que se encuentran entre el \TipoVariable{CustomerId 50} inclusive y el \TipoVariable{CustomerId 55} exclusive, utilizamos la clausula \TipoVariable{AND} de la siguiente manera:
\newline
\newline
\TipoVariable{SELECT * FROM Customers WHERE CustomerId $>$=  50 AND CustomerId $<$ 55}

\subsection{Clausula OR}

Ahora, vamos a la tabla de empleados (Employees) aplicando \TipoVariable{SELECT * FROM Employees}.
\newline
\newline
Luego, queremos ver los datos de las empleadas Nancy o Anne. Para ello, aplicamos \TipoVariable{OR} que funciona como union, es decir:
\newline
\newline
\TipoVariable{SELECT * FROM Employees WHERE FirstName = $"$Nancy$"$ OR FirstName = $"$Anne$"$}

\subsection{Clausula NOT}

Volviendo a la tabla de productos (Products), queremos acceder a todos aquellos productos donde su precio no es mayor a 40. Para ello, utilizamos la cláusula \TipoVariable{NOT} de la siguiente manera:
\newline
\newline
\TipoVariable{SELECT * FROM Products WHERE NOT Price $>$ 40}  

\subsection{Clausula LIMIT}

Ahora, volvemos a la tabla Customers y queremos obtener los primeros 5 clientes a partir del CustomerID 50 y que el país del cliente no sea Alemania (Germany). Entonces, usamos la cláusula LIMIT para realizar esta solicitud de la siguiente manera:
\newline
\newline
\TipoVariable{SELECT * FROM Customers WHERE CustomerID $>=$ 50 AND NOT Country = "Germany" LIMIT 5}
\newline
\newline
Finalmente, podemos ordenar esta solicitud aplicando \TipoVariable{ORDER BY} de la siguiente manera:
\newline
\newline
\TipoVariable{SELECT * FROM Customers WHERE CustomerID >= 50 AND NOT Country = "Germany" ORDER BY RANDOM() LIMIT 5}
\newpage

\subsection{Cláusula GROUP BY y HAVING}

La clausula \textbf{GROUP BY} se utiliza para agrupar uno o varios registros según uno o varios valores de las columnas (campos).
\newline
\newline
Supongamos que queremos calcular el precio promedio de los productos de acuerdo a los proveedores y ordenarlos de manera decreciente. Para ello ejecutamos lo siguiente:
\newline
\newline
\TipoVariable{SELECT SupplierID, ROUND(AVG(Price)) as promedio from Products GROUP BY SupplierID ORDER BY promedio DESC}
\newline
\newline
Ahora queremos seleccionar el nombre del producto (\TipoVariable{ProductName}) también, ejecutamos lo siguiente:
\newline
\newline
\TipoVariable{SELECT ProductName, SupplierID, ROUND(AVG(Price)) as promedio from Products GROUP BY SupplierID ORDER BY promedio DESC}
\newline
\newline
Observemos que el \TipoVariable{ProductName} que retorna es aquel que figura primero con el \TipoVariable{SupplierID} correspondiente.
\newline
\newline
La clausula \TipoVariable{HAVING} nos sirve para realizar filtrado de grupos. A diferencia de la clase \TipoVariable{WHERE} que nos sirve para realizar filtrado de registros.
\newline
\newline
Entonces, si queremos calcular el promedio de los productos de acuerdo a su \TipoVariable{SupplierID}, agruparlos y mostrar aquellos en los que el promedio es mayor a 40 ejecutamos lo siguiente:
\newline
\newline
\TipoVariable{SELECT SupplierID, ROUND(AVG(Price)) as promedio from Products GROUP BY SupplierID HAVING promedio $>$ 40}
\newline
\newline
Observemos que aca no podemos usar la clausula \TipoVariable{WHERE} porque queremos mostrar el promedio que es resultante de una función de agregación \TipoVariable{ROUND(AVG(Price))} y no de un registro.
\newpage

\section{Operadores}

\subsection{Operador !=}

Es un operador de comparación.
 
\subsection{Operador BETWEEN}

El operador \textbf{Between} es un operador de comparación que se utiliza para seleccionar valores en un rango especifico.
\newline
\newline
Supongamos ahora que queremos seleccionar todos aquellos productos donde su precio esta en el rango de 20 a 40 USD.
\newline
\newline
Para ello ejecutamos la siguiente linea:
\newline
\newline
\TipoVariable{SELECT * FROM Products WHERE Price BETWEEN 20 AND 40}
\newline
\newline
También podemos combinarlo con los operadores \TipoVariable{AND} y \TipoVariable{OR} como por ejemplo:
\newline
\newline
\TipoVariable{SELECT * FROM Products WHERE Price BETWEEN 20 AND 40 AND CategoryID = 6}
\newline
\newline
El operador BETWEEN también nos sirve para utilizarlo con fechas. Por ejemplo, si queremos filtrar a aquellos empleados que nacieron entre el año 1960 y 1970 ejecutamos lo siguiente: 
\newline
\newline
\TipoVariable{SELECT * FROM Employees WHERE BirthDate BETWEEN "1960-0-1" AND "1970-0-1"}
\newline
\newline
Observamos también que los limites son inclusivos y que siempre se pasan del limite menor al limite mayor.

\subsection{Operador LIKE}

El operador \textbf{Like} es un operador de comparación utilizado para buscar y filtrar registros en función de ciertos patrones de cadena de texto.
\newline
\newline
Por ejemplo, si queremos filtrar todos los empleados con apellido \TipoVariable{Fuller} podemos ejecutar lo siguiente:
\newline
\newline
\TipoVariable{SELECT * FROM Employees WHERE LastName LIKE "Fuller"}
\newline
\newline
Esencialmente, utilizar \TipoVariable{=} y \TipoVariable{LIKE} es lo mismo pero \TipoVariable{LIKE} tiene ciertos caracteres especiales que nos permiten realizar lo siguiente:
\newline
\newline
\TipoVariable{SELECT * FROM Employees WHERE LastName LIKE "F\%"}. En este caso, estamos realizando una búsqueda de aquellos apellidos que comienzan con \TipoVariable{F} pero no me importa como siguen.
\newline
\newline
\TipoVariable{SELECT * FROM Employees WHERE LastName LIKE "\%r"}. En este caso, estamos realizando una búsqueda de aquellos apellidos que terminan con r pero no me importa como empiezan.
\newline
\newline
\TipoVariable{SELECT * FROM Employees WHERE LastName LIKE "\%a\%"}. En este caso, estamos realizando una búsqueda de aquellos apellidos que tienen la letra a en alguna parte del \TipoVariable{LastName}.
\newline
\newline
\TipoVariable{SELECT * FROM Employees WHERE LastName LIKE \#Full\_\_"}. En este caso, estamos realizando una búsqueda de aquellos apellidos que comienzan con \TipoVariable{Full} y tienen dos caracteres mas pero no me interesan cuales son. Esa es la función del caracteres especial.
\newpage

\subsection{Operador IS NULL y Operador IS NOT NULL}

Supongamos ahora que queremos obtener unicamente aquellos productos que no son nulos y ordenarlos ascendentemente por \TipoVariable{ProductName}. Para ello, ejecutamos lo siguiente:
\newline
\newline
\TipoVariable{SELECT * FROM Products WHERE ProductName IS NOT NULL ORDER BY ProductName ASC}
\newline
\newline
Si queremos obtener unicamente aquellos productos que son nulos y ordenarlos descendentemente por ProductName, ejecutamos lo siguiente:
\newline
\newline
\TipoVariable{SELECT * FROM Products WHERE ProductName IS NOT NULL ORDER BY ProductName DESC}

\subsection{Operador IN}

Introducción a las subconsultas.
\newline
\newline
Supongamos que queremos seleccionar los productos de los proveedores 3,4,5 y 6. Una opción es ejecutar:
\newline
\newline
\TipoVariable{SELECT * FROM Products WHERE SupplierID = 3 OR SupplierID = 4 OR SupplierID = 5 OR SupplierID = 6}
\newline
\newline
La opción mas recomendada es usar el operador \TipoVariable{IN} (funciona como un pertenece en conjuntos), es decir, podemos ejecutar:
\newline
\newline
\TipoVariable{SELECT * FROM Products WHERE SupplierID IN (3,4,5,6)}
\newpage

\section{Funciones de agregación}

Las \textbf{funciones de agregación} nos permiten agregar datos, resumirlos e incluso trabajar con estadísticas sobre los datos.
\newline
\newline
Supongamos que quiero contar la cantidad de nombres que hay en la tabla de empleados y por ende, la cantidad de empleados que tengo. Entonces, ejecuto:
\newline
\newline
\TipoVariable{SELECT count(firstName) FROM Employees}
\newline
\newline
A esto lo permite la función \TipoVariable{count()} que cuenta la cantidad de registros que tiene asociado un campo.
\newline
\newline
Por defecto, me devuelve el resultado con el nombre del campo \TipoVariable{count(firstName)} pero si lo quiero renombrado utilizo \TipoVariable{AS}, es decir:
\newline
\newline
\TipoVariable{SELECT count(firstName) AS Cantidad\_de\_nombres FROM Employees}
\newline
\newline
Ahora, si quiero sumar todos los precios de la tabla Products utilizo la función SUM(), es decir:
\newline
\newline
\TipoVariable{SELECT SUM(Price) AS Suma\_precios FROM Products}
\newline
\newline
Si queremos calcular el promedio de los precios, utilizo la función \TipoVariable{AVG()} de la siguiente manera:
\newline
\newline
\TipoVariable{SELECT AVG(Price) AS promedio FROM Products}
\newline
\newline
Si queremos redondear a entero el promedio de los precios, utilizo la función \TipoVariable{ROUND()} de la siguiente manera:
\newline
\newline
\TipoVariable{SELECT ROUND(AVG(Price)) AS promedio\_redondeado FROM Products}
\newline
\newline
Ahora, si quiero redondear por dos decimales ejecuto:
\newline
\newline
\TipoVariable{SELECT ROUND(AVG(Price), 2) AS promedio\_redondeado\_dos\_unidades FROM Products}
\newline
\newline
Ahora, si quiero calcular el producto de menor precio utilizo \textbf{MIN}:
\newline
\newline
\TipoVariable{SELECT MIN(Price) FROM Products}
\newline
\newline
Ademas, si quiero mostar el nombre del producto de menor precio tambien ejecuto:
\newline
\newline
\TipoVariable{SELECT ProductName, MIN(Price) FROM Products}
\newline
\newline
Ahora, si quiero calcular el producto de mayor precio utilizo \textbf{MAX}:
\newline
\newline
\TipoVariable{SELECT MAX(Price) FROM Products}
\newpage

\section{Subconsultas}

Ahora, el objetivo va a ser relacionar dos tablas. En este caso, vamos a querer relacionar la tabla de Productos (\TipoVariable{Products}) con la tabla de detalles de la orden (\TipoVariable{OrderDetails}) porque queremos obtener la cantidad de productos que se vendieron por cada producto y saber cual es el que genera mas ganancias. Con la tabla \TipoVariable{OrderDetails} podemos calcular cual es producto (de acuerdo a su \TipoVariable{ProductID}) que se vende mas veces pero eso no significa necesariamente que sea el que genera mas ganancia. Por ejemplo, puede haber un producto (supongamos \TipoVariable{ProductID = 2}) que se haya vendido 20 veces y su precio sea de 1USD y puede haber otro producto (supongamos \TipoVariable{ProductID = 5}) que se haya vendido solo 1 vez pero su precio sea de 200USD y observamos que es mayor la ganancia del producto con \TipoVariable{ProductID = 5} que la del producto con \TipoVariable{ProductID = 2}.
\newline
\newline
Entonces, para resolver esto vamos a usar las \textbf{Subconsultas} porque en la tabla \TipoVariable{OrderDetails} tengo el \TipoVariable{ProductID} con la cantidad \TipoVariable{Quantity} de cada producto vendido. Y en la tabla \TipoVariable{Products} tengo el precio (Price) y el \TipoVariable{ProductID} de cada producto para poder realizar precio con cantidad de ventas de cada producto.
\newline
\newline
\textbf{Ejemplo}
\newline
\newline
Comenzamos consultando los campos \TipoVariable{ProductID} y \TipoVariable{Quantity} de la tabla \TipoVariable{OrderDetails} ejecutando lo siguiente:
\newline
\newline
\TipoVariable{SELECT ProductID, Quantity FROM OrderDetails}
\newline
\newline
Ahora, supongamos que quiero ver el nombre del producto pero este campo no lo tengo en la tabla \TipoVariable{OrderDetails} sino en la tabla \TipoVariable{Products}. Y lo puedo acceder a través de su \TipoVariable{ProductID} que se encuentra en ambas tablas.
\newline
\newline
Entonces, para realizar esto ejecutamos lo siguiente:
\newline
\newline
\TipoVariable{SELECT ProductID, Quantity, (SELECT ProductName from Products WHERE OrderDetails.ProductID = ProductID) as nombre\_producto FROM OrderDetails}
\newline
\newline
Por lo tanto, devolvemos de la tabla \TipoVariable{OrderDetails} los campos \TipoVariable{ProductID}, \TipoVariable{Quantity} y el campo resultante de la subconsulta que renombrados como \TipoVariable{nombre\_producto}.
\newline
\newline
El campo \TipoVariable{nombre\_producto} es el resultante de la subconsulta:
\newline
\newline
\TipoVariable{SELECT ProductName from Products WHERE OrderDetails.ProductID = ProductID}
\newline
\newline
En este caso, por cada \TipoVariable{ProductID} de la tabla \TipoVariable{OrderDetails}, busca en la tabla \TipoVariable{Products} el \TipoVariable{ProductID} que coincida con el \TipoVariable{ProductID} de la tabla \TipoVariable{OrderDetails} y retorna el \TipoVariable{ProductName} que se encuentra en la tabla \TipoVariable{Products}.
\newline
\newline
Ahora, queremos ver cual es el producto que mas recaudo. Para ello, ejecutamos lo siguiente:
\newline
\newline
\TipoVariable{SELECT ProductID, SUM(Quantity) as total\_vendido,}
\newline
\TipoVariable{(SELECT Price from Products WHERE OrderDetails.ProductID = ProductID) as Price,}
\newline
\TipoVariable{(SELECT ProductName from Products WHERE OrderDetails.ProductID = ProductID) as Name,}
\newline
\TipoVariable{ROUND(SUM(Quantity)) * (SELECT Price from Products WHERE OrderDetails.ProductID = ProductID) as Total\_recaudado}
\newline
\TipoVariable{FROM OrderDetails}
\newline
\TipoVariable{GROUP BY ProductID}
\newline
\TipoVariable{ORDER BY Total\_recaudado DESC}
\newpage
Ahora, si queremos filtrar aquellos productos donde sus precios sean mayores a 40USD y que no se muestre el campo \TipoVariable{Price}, ejecutamos lo siguiente:
\newline
\newline
\TipoVariable{SELECT ProductID, SUM(Quantity) as total\_vendido,}
\newline
\TipoVariable{(SELECT ProductName from Products WHERE OrderDetails.ProductID = ProductID) as Name,}
\newline
\TipoVariable{ROUND(SUM(Quantity)) * (SELECT Price from Products WHERE OrderDetails.ProductID = ProductID) as Total\_recaudado}
\newline
\TipoVariable{FROM OrderDetails}
\newline
\TipoVariable{WHERE (SELECT Price from Products WHERE OrderDetails.ProductID = ProductID) $>$ 40}
\newline
\TipoVariable{GROUP BY ProductID}
\newline
\TipoVariable{ORDER BY Total\_recaudado DESC}
\newline
\newline
Ahora, si queremos realizar la misma consulta pero también queremos mostrar el campo \TipoVariable{Price}, ejecutamos lo siguiente:
\newline
\newline
\TipoVariable{SELECT ProductID, SUM(Quantity) as total\_vendido,}
\newline
\TipoVariable{(SELECT Price from Products WHERE OrderDetails.ProductID = ProductID) as Price,}
\newline
\TipoVariable{(SELECT ProductName from Products WHERE OrderDetails.ProductID = ProductID) as Name,}
\newline
\TipoVariable{ROUND(SUM(Quantity)) * (SELECT Price from Products WHERE OrderDetails.ProductID = ProductID) as Total\_recaudado}
\newline
\TipoVariable{FROM OrderDetails}
\newline
\TipoVariable{WHERE Price > 40}
\newline
\TipoVariable{GROUP BY ProductID}
\newline
\TipoVariable{ORDER BY Total\_recaudado DESC}
\newline
\newline
Ahora, si quiero obtener solo el campo \TipoVariable{Price} de esta subconsulta, ejecuto lo siguiente:
\newline
\newline
\TipoVariable{SELECT Price FROM (}
\newline
\TipoVariable{SELECT ProductID, SUM(Quantity) as total\_vendido,}
\newline
\TipoVariable{(SELECT Price from Products WHERE OrderDetails.ProductID = ProductID) as Price,}
\newline
\TipoVariable{(SELECT ProductName from Products WHERE OrderDetails.ProductID = ProductID) as Name,}
\newline
\TipoVariable{ROUND(SUM(Quantity)) * (SELECT Price from Products WHERE OrderDetails.ProductID = ProductID) as Total\_recaudado}
\newline
\TipoVariable{FROM OrderDetails}
\newline
\TipoVariable{WHERE Price $>$ 40}
\newline
\TipoVariable{GROUP BY ProductID}
\newline
\TipoVariable{ORDER BY Total\_recaudado DESC)}
\newline
\newline
\textbf{Ejercicio 2}
\newline
\newline
Ahora, supongamos que queremos ver a aquellos empleados que lograron vender mas cantidad de unidades que el promedio. Entonces, comenzamos viendo el nombre (\TipoVariable{FirstName}) y apellido (\TipoVariable{LastName}) de los empleados (\TipoVariable{Employees}) ejecutando: 
\newline
\newline
\TipoVariable{SELECT FirstName, LastName FROM Employees}
\newline
\newline
Ahora, vamos a solicitar la cantidad vendida de cada uno de los empleados con la siguiente subconsulta: 
\newline
\newline
\TipoVariable{SELECT FirstName, LastName, (}
\newline
\TipoVariable{SELECT SUM(od.Quantity) FROM [Orders]  o, [OrderDetails] od}
\newline
\TipoVariable{WHERE o.EmployeeID = e.EmployeeID AND o.orderID = od.orderID}
\newline
\TipoVariable{) as Unidades\_totales}
\newline
\TipoVariable{FROM [Employees] e}
\newpage
Ahora, como queremos seleccionar a aquellos empleados tales que las \TipoVariable{Unidades\_totales} sean mayor al promedio podriamos intentar ejecutar \TipoVariable{WHERE Unidades\_totales $>$  AVG(Unidades\_totales)} pero esto no se puede. Entonces, creamos una subconsulta virtual que vuelva a pedir la cantidad de \TipoVariable{Unidades\_totales}, calculamos el promedio y comparamos con \TipoVariable{Unidades\_totales} de la siguiente manera:
\newline
\newline
\TipoVariable{SELECT FirstName, LastName, (}
\newline
\TipoVariable{SELECT SUM(od.Quantity) FROM [Orders]  o, [OrderDetails] od}
\newline
\TipoVariable{WHERE o.EmployeeID = e.EmployeeID AND o.orderID = od.orderID}
\newline
\TipoVariable{) as Unidades\_totales}
\newline
\TipoVariable{FROM [Employees] e}
\newline
\TipoVariable{WHERE Unidades\_totales > (SELECT AVG(Unidades\_totales) FROM (SELECT}
\newline
\TipoVariable{(SELECT SUM(od.Quantity) FROM [Orders]  o, [OrderDetails] od}
\newline
\TipoVariable{WHERE o.EmployeeID = e2.EmployeeID AND o.orderID = od.orderID}
\newline
\TipoVariable{) as Unidades\_totales}
\newline
\TipoVariable{FROM [Employees] e2}
\newline
\TipoVariable{GROUP BY e2.EmployeeID}
\newline
\TipoVariable{)}
\newline
\TipoVariable{) }
\newpage

\section{Joins}

Los \textbf{Joins} son una operación que utilizamos en las bases de datos para poder combinar la información de dos o mas tablas en una base de datos pero que esa información se devuelva en una sola tabla.  

\subsection{Cross Join}

Si ejecutamos:
\newline
\TipoVariable{SELECT * FROM Employees e CROSS JOIN Orders o}
\newline
\newline
Obtenemos una sola tabla con los campos unidos de \TipoVariable{Employees} y \TipoVariable{Orders} de 1960 registros. Como la lista de empleados esta compuesta por 10 registros y la tabla de \TipoVariable{Orders} esta compuesta por 196 registros, al aplicar un \textbf{Cros Join}, le asigna a cada empleado cada uno de los 196 registros y los combina en una sola tabla.
\newline
\newline
Esto es analogo a ejecutar \TipoVariable{SELECT * FROM Employees e, Orders o}.

\subsection{Inner Join (Join)}

Ahora, si queremos que se unan los datos del empleado que vendió cada producto (se encuentran en \TipoVariable{Orders}) ejecutamos lo siguiente.

\subsection{Creación de Tablas}

Para crear una Tabla directamente a partir de lineas de código, ejecutamos las siguientes lineas:
\newline
\newline
\TipoVariable{CREATE TABLE $"$Rewards$"$ (recompensa) (}
\newline
\TipoVariable{$"$RewardID$"$ INTEGER,}
\newline
\TipoVariable{$"$EmployeeID$"$ INTEGER,}
\newline
\TipoVariable{$"$Reward$"$ INTEGER,}
\newline
\TipoVariable{$"$Month$"$ TEXT.}
\newline
\TipoVariable{PRIMARY KEY($"$RewardID$"$ AUTOINCREMENT)}
\newline
\TipoVariable{)}
\newline
\newline
En este caso \TipoVariable{RewardID} es la clave primaria, \TipoVariable{EmployeeID} es el empleado que recibe la recompensa, \TipoVariable{Reward} indica la recompensa en USD y \TipoVariable{Month} indica el mes.
\newline
\newline
Luego, indicamos que \TipoVariable{RewardID} va a ser la clave primaria autoincrementable ejecutando:
\newline
\newline
\TipoVariable{PRIMARY KEY($"$RewardID$"$ AUTOINCREMENT)}    
\newline
\newline
Finalmente, obtenemos la tabla con todos los campos declarados anteriormente vacios porque todavía no les insertamos datos.
\newline
\newline
Ahora, vamos a insertar 6 datos. 5 datos de empleados diferentes donde en cada mes un empleado distinto va a recibir un premio y un mes donde ningún empleado recibe un premio. Es decir:
\newline
\newline
\TipoVariable{INSERT INTO Rewards (EmployeeID, Reward, Month) VALUES}
\newline
\newline
\TipoVariable{(3, 200, $"$January$"$),}
\newline
\TipoVariable{(2, 180, $"$February$"$),}
\newline
\TipoVariable{(5, 250, $"$March$"$),}
\newline
\TipoVariable{(1, 280, $"$April$"$),}
\newline
\TipoVariable{(8, 160, $"$March$"$),}
\newline
\TipoVariable{(null, null, $"$June$"$)}
\newline
\newline
Entonces, si queremos unir la información de los empleados que recibieron los premios ejecutamos lo siguiente:
\newline
\newline
\TipoVariable{SELECT * FROM Employees e}
\newline
\TipoVariable{INNER JOIN Rewards r ON e.EmployeeID = r.EmployeeID}
\newline
\newline
Pero si queremos obtener el nombre, la recompensa y el mes ejecutamos lo siguiente:
\newline
\newline
\TipoVariable{SELECT FirstName, Reward, Month FROM Employees e}
\newline
\TipoVariable{INNER JOIN Rewards r ON e.EmployeeID = r.EmployeeID}
\newline
\newline
Por lo tanto, un \TipoVariable{INNER JOIN} representa la intersección entre conjuntos.

\subsection{Left Join}

Ahora, si quiero ejecutar un \textbf{Left Join} ejecuto lo siguiente:  
\newline
\newline
\TipoVariable{SELECT FirstName, Reward, Month FROM Employees e}
\newline
\TipoVariable{LEFT JOIN Rewards r ON e.EmployeeID = r.EmployeeID}
\newline
\newline
Por lo tanto, un \textbf{Left Join} representa la diferencia entre conjuntos (en este caso \TipoVariable{Employees - Rewards}). Es decir, muestra a todos los empleados de la tabla \TipoVariable{Employees} y solo les une la recompensa y el mes a aquellos en los que coincide su \TipoVariable{ID}. Los demás campos los deja en \TipoVariable{NULL}. 
\newline
\newline
Ahora, si queremos que la diferencia sea (en este caso \TipoVariable{Rewards - Employees}) ejecutamos:
\newline
\newline
\TipoVariable{SELECT FirstName, Reward, Month FROM Rewards r}
\newline
\TipoVariable{LEFT JOIN Employees e ON e.EmployeeID = r.EmployeeID}
\newline
\newline
Observemos que en SQLite no podemos ejecutar un \textbf{Right Join}, es decir:
\newline
\newline
\TipoVariable{SELECT FirstName, Reward, Month FROM Employees e}
\newline
\TipoVariable{RIGHT JOIN Rewards r ON e.EmployeeID = r.EmployeeID}
\newline
\newline
Entonces, lo que hacemos para lograr esto es invertir el orden de las tablas como se menciono anteriormente pero debemos aclararlo en un comentario.
\newline
\newline
Ahora, si queremos unir en una sola tabla el resultado de dos consultas utilizamos \TipoVariable{UNION}. Es decir, ejecutamos:
\newline
\newline
\TipoVariable{SELECT FirstName, Reward, Month FROM Employees e}
\newline
\TipoVariable{LEFT JOIN Rewards r ON e.EmployeeID = r.EmployeeID}
\newline
\newline
\TipoVariable{SELECT FirstName, Reward, Month FROM Rewards r}
\newline
\TipoVariable{LEFT JOIN Employees e ON e.EmployeeID = r.EmployeeID}
\newline
\newline 
Por lo tanto, estamos simulando un \TipoVariable{FULL JOIN} uniendo un \TipoVariable{LEFT JOIN} con una simulación de \TipoVariable{RIGHT JOIN}.

\subsection{Union}

\textbf{Union} es una cláusula que se utiliza para combinar dos o mas tablas.
\newline
\newline
\textbf{.} \TipoVariable{UNION ALL} devuelve la suma de las dos consultas. Por ejemplo, si tengo una tabla con 4 filas y otra con 3 filas, el resultado es una tabla con 7 filas donde los campos son coincidentes.
\newline
\newline
\textbf{.} \TipoVariable{UNION} también devuelve la suma de las dos consultas pero solo deja la primera aparición de todas las filas que están repetidas.
\newpage

\section{Cardinalidad}

La \textbf{carnalidad} en el contexto de base de datos se utiliza para especificar cual es la relación entre dos entidades (generalmente tablas).
\newline
\newline
Comencemos viendo el ejemplo de la base de datos de NorthWind que venimos estudiando.
\newline
\newline
\textbf{.} La tabla \TipoVariable{Customers} se une con la tabla \TipoVariable{Orders} mediante el \TipoVariable{CustomerID}. En este caso la relación es \TipoVariable{1:n} porque 1 orden puede haber sido hecho únicamente por un cliente (\TipoVariable{customer}) y \TipoVariable{n} el cliente puede realizar muchas (\TipoVariable{n}) ordenes.
\newline
\newline
\textbf{.} La tabla \TipoVariable{Employees} se une con la tabla \TipoVariable{Orders} mediante el \TipoVariable{EmployeeID}. En este caso la relación es \TipoVariable{1:n} porque 1 orden puede haber sido hecho únicamente por un vendedor/empleado (\TipoVariable{employee}) y \TipoVariable{n} porque el empleado puede realizar muchas (\TipoVariable{n}) ordenes/ventas.
\newline
\newline
\textbf{.} La tabla \TipoVariable{Shippers} se une con la tabla \TipoVariable{Orders} mediante el \TipoVariable{ShipperID}. En este caso la relación es \TipoVariable{1:n} porque 1 empresa solo se puede encargar del envío de un producto y \TipoVariable{n} porque una empresa se encargar de muchos (\TipoVariable{n}) envíos.
\newline
\newline
\textbf{.} La tabla \TipoVariable{Orders} se une con la tabla \TipoVariable{OrderDetail} mediante el \TipoVariable{OrderID}. En este caso la relación es \TipoVariable{1:n} porque los detalles de una orden se corresponden únicamente con 1 orden y \TipoVariable{n} porque 1 orden puede tener muchos (\TipoVariable{n}) detalles.
\newline
\newline
\textbf{.} La tabla \TipoVariable{OrderDetails} se une con la tabla \TipoVariable{Products} mediante el \TipoVariable{ProductID}. En este caso la relación es \TipoVariable{n:1} porque un detalle hace referencia únicamente a 1 producto y \TipoVariable{n} porque muchos (\TipoVariable{n}) productos puede hacen referencia a diferentes detalles de orden.
\newline
\newline
\textbf{.} La tabla \TipoVariable{Products} se une con la tabla \TipoVariable{Suppliers} mediante el \TipoVariable{SupplierID}. En este caso la relación es \TipoVariable{n:1} porque un producto solo puede estar relacionado a un proveedor (supplier) y \TipoVariable{n} porque un proveedor puede proveer de varios (\TipoVariable{n}) productos.
\newline
\newline
\textbf{.} La tabla \TipoVariable{Products} se une con la tabla \TipoVariable{Categories} mediante el \TipoVariable{CategoryID}. En este caso la relación es \TipoVariable{n:1} porque 1 producto solo puede estar relacionado a una categoría (category) y \TipoVariable{n} porque un categoría puede estar asociada a varios (\TipoVariable{n}) productos.

\section{Normalización}

La normalización es un proceso dentro del diseño de la base de datos que sirve para eliminar anomalías en los datos, hacer que la base de datos sea mas eficiente y poder hacer consultas mas efectivas.
\newpage

\section{Indices}

Un \textbf{indice} tiene el objetivo de mejorar el rendimiento de las consultas en una base de datos organizándolos correctamente.
\newline
\newline
\textbf{.} Indices primarios o únicos (primary key por ejemplo): Los indices primarios no pueden tener valores nulos, es decir, es el único tipo de indice que no permite tener valores nulos
\newline
\newline
Por ejemplo, vamos a crear un indice en campo LastName de la tabla Employees de la siguiente manera:
\newline
\newline
\TipoVariable{CREATE INDEX name on Employees (FirstName)}
\newline
\newline
El problema de esto es que el campo \TipoVariable{FirstName} se convierte en un indice y puede admitir campos nulos y campos duplicados.
\newline
\newline
Si agregamos \TipoVariable{UNIQUE} adelante de \TipoVariable{INDEX}, crea un indice único para el nombre (\TipoVariable{FirstName}). Es decir, cuando se quiera insertar un valor que se repita, la consulta no nos va a insertar el registro porque es un valor repetido o duplicado gracias al \TipoVariable{UNIQUE}.
\newline
\newline
\TipoVariable{CREATE UNIQUE INDEX name on Employees (FirstName, LastName)}
\newline
\newline
También puedo crear campos únicos combinados, es decir, los campos \TipoVariable{FirstName} y \TipoVariable{LastName} son únicos, es decir, cuando quiera insertar un campo donde el nombre y apellido son repetidos, me va a arrojar un error.
\newline
\newline
\textbf{Ejemplo}
\newline
\newline
Queremos consultar todos los productos que tuvieron mas de 10 ventas y que se vendieron luego de la fecha \TipoVariable{$"$1996-07-04$"$}. Es decir: 
\newline
\newline
\TipoVariable{SELECT * FROM OrderDetails od JOIN Orders o WHERE o.OrderID = od.OrderID AND OrderDate $>$ $"$1996-07-04$"$ AND od.Quantity $>$ 10}
\newline
\newline
Como utilizamos muchos los campos \TipoVariable{OrderDate} y \TipoVariable{Quantity}, creamos los siguientes indices:
\newline
\newline
\TipoVariable{CREATE INDEX idx\_orderdetails\_quantity ON OrderDetails (Quantity);}
\newline
\TipoVariable{CREATE INDEX idx\_orders\_quantity ON Orders (OrderDate)}
\newline
\newline
Luego, volvemos a ejecutar la consulta: 
\newline
\newline
\TipoVariable{SELECT * FROM OrderDetails od JOIN Orders o WHERE o.OrderID = od.OrderID AND OrderDate $>$ $"$1996-07-04$"$ AND od.Quantity $>$ 10}
\newline
\newline
Y observamos que no se produce una mejora en el rendimiento (sigue demorando entre 17ms y 20ms).
\newline
\newline
Ahora, si quiero eliminar los indices, ejecuto:
\newline
\newline
\TipoVariable{DROP INDEX idx\_orderdetails\_quantity;}
\newline
\TipoVariable{DROP INDEX idx\_orders\_quantity}
\newline
\newline
Ahora, si ejecutamos nuevamente la consulta:
\newline
\newline
\TipoVariable{SELECT * FROM OrderDetails od JOIN Orders o WHERE o.OrderID = od.OrderID AND OrderDate $>$ $"$1996-07-04$"$ AND od.Quantity $>$ 10}
\newline
\newline
Vemos que demora entre 28ms y 31ms. Demora mas que antes de borrar los indices.
\newpage

\section{Vistas}

Las vistas son tablas virtuales. Las vistas no almacenan datos sino que referencian a una consulta que nos devuelve una vista.
\newline
\newline
\textbf{Ejemplo}
\newline
\newline
Comenzamos consultando por aquellos productos donde el \TipoVariable{ProductID $>$ 20} y lo ordenamos por el id del producto de forma descendente. Es decir, seleccionamos y ordenamos los productos del ultimo al primero que fue cargado. O sea:
\newline
\newline
\TipoVariable{SELECT * FROM Products WHERE ProductID > 20 ORDER BY ProductID DESC} 
\newline
\newline
Ahora, si queremos obtener únicamente el id, name y el price ejecutamos:
\newline
\newline
\TipoVariable{SELECT ProductID, ProductName, Price FROM Products WHERE ProductID $>$ 20 ORDER BY ProductID DESC}
\newline
\newline
Por lo tanto, a esta tabla resultante le puede crear una \textbf{vista} de la siguiente manera:
\newline
\newline
\TipoVariable{CREATE VIEW Productos\_simplificados AS SELECT ProductID, ProductName, Price FROM Products WHERE ProductID $>$ 20 ORDER BY ProductID DESC}
\newline
\newline
Ahora, puedo ver esta tabla ejecutando simplemente \TipoVariable{SELECT * FROM Productos\_simplificados}
\newline
\newline
Por ultimo, si queremos eliminar una vista ejecutamos:
\newline
\newline
\TipoVariable{DROP VIEW IF EXISTS Productos\_simplificados}
\newline
\newline
La clausula \TipoVariable{IF EXISTS} la ejecutamos para evitar tener errores porque por ejemplo si borramos la vista ejecutando:
\newline
\newline
\TipoVariable{DROP VIEW Productos\_simplificados}
\newline
\newline
Borramos la vista correctamente pero si volvemos a ejecutar \TipoVariable{DROP VIEW Productos\_simplificados}, arroja un error porque la vista ya fue eliminada. Entonces, con \TipoVariable{IF EXISTS} nos aseguramos chequear si existe la vista antes de borrarla.

\section{Funciones definidas por el usuario}

Una función definida por el usuario es una función que puede ser utilizada por SQLite y esta creada para poder recibir la información que puede ser ejecutada en una consulta, es decir, la función toma esos valores, los procesa y devuelve una salida. Ademas, debe estar registrada en SQLite. A su vez, esta función no va a estar creada en SQLite sino en un lenguaje anfitrión como por ejemplo Python  

\end{document}
